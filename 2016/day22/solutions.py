import pandas as pd

df = pd.read_csv('input', skiprows=1, sep='\s+')
df['Used'] = df['Used'].str.replace('T', '').astype(int)
df['Avail'] = df['Avail'].str.replace('T', '').astype(int)
df['Size'] = df['Size'].str.replace('T', '').astype(int)
df['Filesystem'] = df['Filesystem'].str.replace('/dev/grid/node-', '')
df = df.set_index('Filesystem')

# Part one
viable = 0
used = df.Used.values
avail = df.Avail.values
for i in range(len(df)):
    if used[i] == 0:
        continue
    for j in range(len(df)):
        if i != j and used[i] <= avail[j]:
            viable += 1

print(viable)

# Part two
# First, let us visualize what the map actually looks like
ss = []
for y in range(30):
    s = [str(y).zfill(2), ' ']
    for x in range(34):
        if x == 0 and y == 0:
            s.append('F')
        elif x == 33 and y == 0:
            s.append('G')
        elif df.loc[f'x{x}-y{y}'].Used == 0:
            s.append('_')
        elif df.loc[f'x{x}-y{y}'].Used > 90:
            s.append('#')
        else:
            s.append('.')
    ss.append(s)

print('\n'.join(''.join(s) for s in ss))

# Here's the result:
# 00 F................................G
# 01 ..................................
# 02 ..################################
# 03 ..................................
# 04 ..................................
# 05 ..................................
# 06 ..................................
# 07 ..................................
# 08 ..................................
# 09 ..................................
# 10 ..................................
# 11 ..................................
# 12 ..................................
# 13 ..................................
# 14 ..................................
# 15 ..................................
# 16 ..................................
# 17 ..................................
# 18 ..................................
# 19 ..................................
# 20 ..................................
# 21 ..................................
# 22 ..................................
# 23 ..................................
# 24 ..................................
# 25 ...._.............................
# 26 ..................................
# 27 ..................................
# 28 ..................................
# 29 ..................................

# From this, we can easily read off the optimal solution, as this
# is essentially a sliding puzzle. We move the empty node all the
# way up next to G, passing the "wall" of large nodes. This can be
# done in 3 + 25 + 31 moves. We then swap places with G which costs
# another move. From there, we can spend 5 moves to move G one more
# step to the left, by moving around it, then swapping place. We
# need to do this a total of 32 times, before G ends up at F.
print(3 + 25 + 31 + 1 + 5*32)
